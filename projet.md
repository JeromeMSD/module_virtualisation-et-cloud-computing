# [![ESIREM](https://esirem.u-bourgogne.fr/wp-content/uploads/2024/06/logo-polytech-ub-300x150-1.png)](https://esirem.u-bourgogne.fr/)
# EXAMEN PRATIQUE - ILIA-SQR - Virtualisation & Cloud Computing

> [!WARNING]
> √Ä rendre au plus tard le **2 semaines apr√®s votre derni√®re sc√©ance de TP.** (TP1 ILIA: `16 Janvier 2025 √† 23h59`, Autres groupes: `12 Fevrier 2025 √† 23h59`)

Sommaire
---

* [Sujet du projet](#sujet-du-projet)
* [Fondation](#fondation)
* [Environnement](#environnement-logiciel)
* [Application](#application)
* [Exigences projet](/docs/exigences-projet.md)

---

Le projet not√© du module de Virtualisation & Cloud computing √©valuera comp√©tences et bonnes pratiques de d√©veloppement vues en cours. La notation tiendra compte de l'infrastructure d√©ploy√©e, des fonctionnalit√©s d√©ploy√©es dans l'application, de la bonne mise en place des points d‚Äôexigences projets, de votre compr√©hension de votre code ainsi que de la collaboration entre les membres du groupe.

---

# Sujet du projet

Vous allez r√©aliser une **Calculatrice Cloud Native**.

De la d√©claration des ressources d'infrastructure, √† l'impl√©mentation des composants logiciels de l'application tout en passant par la configuration de l'environnement.

## D√©roul√© du projet

Ce projet va se d√©rouler comme la mise sur le march√© d'une application.

√Ä l'image de l'√©quipe tech d'une startup, vous allez deployer une application pour la mettre √† disposition d'utilisateurs.
Vous passerez donc par la conception et le provisionnement d'une infratructre √† la d√©claration des fichiers de d√©ploiement
pour d√©ployer sans oublier la conception de l'application.

Pour marcher sur les traces du Cloud Natif, nous allons mettre en place de bonnes pratiques d√®s le d√©part :

* **L'infrastructure de base** sera d√©finie en code (IaC) via `Terraform`.
* **La configuration et l'architecture de d√©ploiment** sera faite via `Kubernetes`.
* **L'application** sera architectur√©e d'un point de vue logique comme une grappe de microservices:

  ```mermaid
  graph TB;
      A(Utilisateur) --> B[Frontend]
      B -->|"Envoi du calcul
              ou
              Demande d'un r√©sultat"| C[API]
      C -->|Transmission du calcul √† faire | E[\RabbitMQ/]
      -.->
      F(["Consumer
          ( calcul )"]) -->|R√©cup√®ration d'un calcul| E
      F -->|Stockage du r√©sultat| D
      C <-->|Acc√®s aux r√©sultats| D[(Redis)]
  ```

### Faire place nette

Utilisez votre d√©p√¥t utilis√© en TD.
D√©placez votre travail de TD ( fichiers, dossiers et `README.md` ) dans un dossier du m√™me nom √† la racine du d√©p√¥t.

Cr√©ez un nouveau `README.md` √† la racine du projet qui servira de rapport pour le projet (pour l‚Äôinstant vous pouvez y saisir les membres du groupe).

Cr√©ez les dossiers `foundation`, `kubernetes` et `application`, qui serviront √† stocker respectivement, les fichiers **Terraform**, **Kubernetes** et **les fichiers de l'application** √† d√©ployer.

> Chacun de ces dossiers contiendra un `README.md` d√©di√©.

Dans le dossier `application`, vous organiserez le contenu en trois dossiers:

* un pour le `frontend` pour le code de l'interface utilisateur.
* un pour le `backend`, pour le code de votre API.
* un pour le `consumer`, pour le code de votre consommateur de message.

Le fichier `application/README.md` contiendra √©galement les commandes n√©c√©ssaires pour contruire les images de conteneur du projet ainsi que celles pour en pousser une version dans **Google Artifact Registry**.

## C'est parti ! üöÄ √Ä partir d'ici, chaque section peut √™tre r√©alis√©e ind√©pendement.

---
## Fondation

[![terraform](https://img.shields.io/badge/terraform-%235835CC.svg?style=for-the-badge&logo=terraform&logoColor=white)](https://developer.hashicorp.com/terraform/docs)
[![scaleway](https://img.shields.io/badge/scaleway-663399?style=for-the-badge&logo=scaleway&logoColor=white)](https://registry.terraform.io/providers/scaleway/scaleway/latest/docs)

Qui dit "projet" dit aussi "contraintes suppl√©mentaires" ! Nous voulons une calculatrice qui soit h√©berg√©e en France **et** par un fournisseur fran√ßais. üêì

```hcl
terraform {
  required_providers {
    scaleway = {
      source = "scaleway/scaleway"
    }
  }
  required_version = ">= 0.13"
}
```

En utilisant le provider Terraform de [Scaleway](https://registry.terraform.io/providers/scaleway/scaleway/latest/docs), fournisseur de Cloud fran√ßais, d√©crivez l'infrastructure as code:

* Un **registre** de conteneur.
* Un cluster **Kubernetes**.
* Une base de donn√©es de `development` et de `production`.
* Une **entr√©e DNS** pour `calculatrice-<nombinome1>-<nombinome2>.polytech-dijon.kiowy.net` pour r√©soudre l'IP d'un des **LoadBalancers**.
* Une **entr√©e DNS** pour `calculatrice-dev-<nombinome1>-<nombinome2>.polytech-dijon.kiowy.net` pour r√©soudre l'IP d'une des **LoadBalancers**.
* Un **LoadBalancer** de `development` et un **LoadBalancer** de `production`.

> Stocker les fichiers dans le dossier `foundation`

```mermaid
graph LR
  subgraph k8s ["Cluster Kubernetes"]
    direction TB
    node1
    node2
    node3
  end
  lbA["LoadBalancer
        (production)"] --> k8s
  lbB["LoadBalancer
        (development)"]  --> k8s
  dns1(["DNS
        calculatrice-dev.polytech-dijon.kiowy.net"]) --> lbB
  dns2(["DNS
        calculatrice.polytech-dijon.kiowy.net"]) --> lbA
  k8s --> db["Base de donn√©es
              (production)"]
  k8s --> reg[registre de conteneur]
  k8s --> db2["Base de donn√©es
              (develop)"]
```

**Vous devez utiliser des variables** pour nommer les ressources d√©di√©es √† un environment selon les environments.

> [!TIP]
> Ce qui veut dire que les fichiers ne contiendrons qu'une instance de chaque type de ressource
> (une pour le registre, une pour le cluster, une pour **les** bases de donn√©es, une pour **les** entr√©es DNS et une pour **les** LoadBalancers).

Cette section est termin√©e si les commandes `terraform fmt`, `terraform validate` et `terraform plan` s'ex√©cutent sans erreur dans le dossier `foundation`.

> [!important]
> Le r√©sultat du `terraform plan` est √† ajouter au README.md de ce m√™me dossier.

> [!caution]
> L'API Terraform de Scaleway ne n√©c√©ssite pas d'authentification pour r√©aliser les commandes `terraform fmt`, `terraform validate` et `terraform plan`. Vous pouvez donc r√©aliser des commandes sans √™tre connect√©. **Vous n'avez pas besoin de vous cr√©er un compte chez Scaleway pour r√©aliser cette section.**

> [!NOTE]
> [Documentation Terraform](https://developer.hashicorp.com/terraform/docs) **-** [Documentation Scaleway Terraform](https://registry.terraform.io/providers/scaleway/scaleway/latest/docs) **-** [Documentation Scaleway](https://www.scaleway.com/en/docs/)

## Environnement logiciel

[![k8s](https://img.shields.io/badge/kubernetes-326CE5.svg?style=for-the-badge&logo=kubernetes&logoColor=white)](https://kubernetes.io/docs/home/)

Utilisez Kubernetes pour d√©ployer votre application au sein d'un namespace `nombinome1-nombinome2`.

1. Pour chaque *microservice*, d√©clarez un [ReplicaSet](https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/) et un [Service](https://kubernetes.io/fr/docs/concepts/services-networking/service/) pour exposer le conteneur de ce dernier.
2. Passer en variable environnement les variables permettant la connexion entre les services qui doivent l'√™tre.
3. Veillez √† avoir dans vos [ReplicaSet](https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/) les param√™tres suivants au niveau du conteneur.
    ```yaml
    # ...
    resources:
      requests:
        cpu: "4m"
        memory: "32Mi"
    ```
4. Exposer le service frontend et le backend via une r√®gle [Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/) pour le nom de domaine d√©fini dans la section [Fondation](#fondation).

> [!caution]
> **Vous n'avez pas besion de d√©ployer d'Ingress Controller !** Il est d√©j√† pr√©sent au sein du cluster.
>
> Cr√©er uniquement un objet de `kind: Ingress` pour lequel l'attribut `ingressClassName` vaut `nginx`.

Une fois la configuration d√©ploy√©e, acc√©der √† votre nom de domaine via un navigateur doit vous permettre d'utiliser la calculatrice.

**Schema r√©capitulatif**

```mermaid
 graph LR
    subgraph "Kubernetes"
    subgraph "Namespace du bin√¥me"
    subgraph "front-replicaset"
      pod-front
    end
    subgraph "api-replicaset"
      pod-api
    end
    subgraph "redis-replicaset"
      pod-redis[("Redis
                  pod")]
    end
    subgraph "rabbitmq-replicaset"
      pod-rabbitmq[\" RabbitMQ
                      pod"/]
    end
    subgraph "consumer-replicaset"
      pod-consumer
    end
    svc-api([svc-api]) --> pod-api
    svc-redis([svc-redis]) --> pod-redis
    svc-rabbitmq([svc-rabbitmq]) --> pod-rabbitmq
    pod-consumer -.-> svc-rabbitmq
    pod-consumer -.-> svc-redis
    pod-api -.-> svc-redis
    pod-api -.-> svc-rabbitmq
    ing -->|"${VOTRE_URL}/api"| svc-api
    ing(Ingress NGINX rules) -->|"${VOTRE_URL}/"| svc-front
    svc-front([svc-front]) --> pod-front
    end
    end
```

**Les liens en pointill√©s ne sont pas √† d√©crire de fa√ßon explicite dans la configuration Kubernetes, mais seront √† coder dans les applications.**

Cette section est termin√©e si vous acc√©dez √† votre application en utilisant l'URL `calculatrice-<nombinome1>-<nombinome2>.polytech-dijon.kiowy.net` dans votre navigateur.

> [!tip]
> Tester l'acc√®s externe en ajoutant votre nom DNS au fichier hosts ! üöÄ
> 
> **Linux & MacOS -** Ex√©cuter la commande suivante avec votre URL.
> ```
> sudo echo "34.77.144.136 calculatrice-<nombinome1>-<nombinome2>.polytech-dijon.kiowy.net" >> /etc/hosts
> ```
> **Windows -**
> Ouvrer le fichier `C:\Windows\System32\drivers\etc\hosts` avec un √©diteur de texte et ajouter √† la fin du fichier la ligne suivante avec votre URL.
> ```
> 34.77.144.136 calculatrice-<nombinome1>-<nombinome2>.polytech-dijon.kiowy.net
> ```


> [!NOTE]
> Documentations pour la section:
> [Kubernetes](https://kubernetes.io/docs/home/)
> **-** [K8S Pod](https://kubernetes.io/docs/concepts/workloads/pods/)
> **-**  [K8S Service](https://kubernetes.io/fr/docs/concepts/services-networking/service/)
> **-**  [K8S ReplicaSet](https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/)
> **-**  [K8S Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)
> **-**  [K8S Namespace](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/)
> **-** [K8S Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/)
> **-**  [kubectl Cheat Sheet](https://kubernetes.io/fr/docs/reference/kubectl/cheatsheet/)

## Application

Concevoir une API simple.

La calculatrice doit permettre les **additions**, les **soustractions**, les **multiplications** et les **divisions**.

Pour demander ces calculs :

* `POST` &nbsp;: Envoyer un tuple pour demander un calcul. *( Renvoie l'`id` de l'op√©ration )*
* `GET`  &emsp;: R√©cup√©rer un r√©sultat √† partir un `id`. *( Renvoie le r√©sultat du calcul )*

Pour vos tests, vous pouvez stocker les r√©sultats dans une variable dictionnaire.

> [!TIP]
> Bonne pratique : pour plus de clart√©, utilisez un pr√©fix pour vos routes api.
> **exemple :**`/api/ma_route` ou `/v1/ma_route` pour le versionning des endpoints.

Utilisez `curl` pour demander des calculs et r√©cup√©rer le r√©sultat. [Rappel HTTP/S et API](/docs/rappel-http.md)

```bash
# Rappel
curl -X POST/GET -h localhost:PORT -d "tuple={}"
```

### Externaliser la donn√©e ( car l'API peut tomber üò± )

Et que ce soit par contrainte produit ou *par go√ªt de la chose bien faite* :
on va √©viter de perdre toutes les demandes de calcul en cours pour un calcul impossible !

Utilisons [Redis](https://redis.io/docs/about/) comme Redis externe √† l'API pour la gestion des r√©sultats.

#### Redis

Utilisez Redis comme serveur de donn√©es, c‚Äôest un syst√®me de stockage **cl√©/valeur** qui utilise le port **6379** pour communiquer. Vous pouvez le lancer dans un conteneur via la commande suivante :

```bash
# √Ä ex√©cuter dans un autre terminal.
docker run -p 6379:6379 --name myredis --rm redis
```

Oui, on pourrait utiliser `-d` pour lancer le conteneur en mode `detached` mais dans un terminal on peut voir les logs, pratique pour d√©buguer ! üßê

> [!tip]
> Utilisez [redis-cli](https://redis.io/docs/ui/cli/) pour acc√©der √† `redis` via les commandes `set`, `get`, `keys`.

#### Mise en place de la connexion Redis dans l'API

Connectons maintenant l‚ÄôAPI √† la Redis
Documentation üëâ [python et redis](https://pypi.org/project/redis/)

```python
import redis
r = redis.Redis(host='localhost', port=6379, db=0)

# Ajout de variable
r.set('foo', 'bar')                 # Retourne True si r√©ussite

# Lecture de 
r.get('foo')                        # Retourne la value de foo
```

Remplacer le syst√®me de stockage des op√©rations et des r√©sultats (pr√©c√©demment en variable) par un stockage via **Redis**

> Utilisez `curl` pour demander des calculs et r√©cup√©rer le r√©sultat.

### G√©rer les calculs avec des files d'attente

[![LapinMQ](https://img.shields.io/badge/rabbitmq-%23FF6600.svg?&style=for-the-badge&logo=rabbitmq&logoColor=white)](https://rabbitmq.com/)

Via un nouveau conteneur, d√©marrez [**RabbitMQ**](https://rabbitmq.com/) qui servira de serveur de files.

```bash
docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.12-management
```

> [!tip]
> Si vous n'avez pas eu l'occasion d'essayer lors du TD sur la conteneurisation, tester RabbitMQ avec le tutoriel suivant ! üëâ [ RabbitMQ Hello World ](https://rabbitmq.com/tutorials/tutorial-one-python.html)

Comment la file d'attente doit √™tre ajout√©e √† l'API: chaque fois que l'API re√ßoit le calcul √† effectuer, elle cr√©e un message avec op√©rateur et op√©randes et le place dans la queue.
**Un autre programme est donc √† d√©velopper**, il sera charg√© de consommer les messages. Pour chaque message, il r√©alisera le calcul et le stokera le resultat dans le redis.

### Impl√©menter une interface utilisateur (Frontend)

√áa vous dit un peu de design et d‚Äôimpl√©mentation d‚Äôinterface ?

**Une seule consigne :**
Cr√©er un frontend qui permet √† l‚Äôutilisateur de saisir et d‚Äôenvoyer des demandes de calcul √† l‚ÄôAPI ou de r√©cup√©rer des r√©sultats.

### Dockerization

[![docker](https://img.shields.io/badge/DOCKER-blue?style=for-the-badge&logo=docker&logoColor=white)](https://docs.docker.com/)

Conteneurisez les microservices `backend`, `frontend` et `consumer`.

### Exemple de fonctionnement pour demander la r√©alisation une addition

```mermaid
graph LR
    user([Utilisateur]) -->|saisit une addition| F[Frontend]
    F -->|"HTTP POST /api/addition"| B[Backend]
    B -->|"{id, calcul √† faire}"| Q[\ RabbitMQ /]
    B -.->|HTTP 200 OK| F
    C[Consumer] -->|"r√©cup√©re le dernier message"| Q[\ RabbitMQ /]
    C -->|"redis.set(id, resultat du calcul)"| R[(Redis DB)]
```

### Exemple de fonctionnement pour demander un r√©sultat

```mermaid
graph LR
    user([Utilisateur]) -->|saisit id du calcul √† r√©cup√©rer| F[Frontend]
    F -->|"HTTP GET /api/result/{id}"| B[Backend]
    B -->|"redis.get(id)"| R[(Redis DB)]
    R -.->|"r√©sultat ou null"| B
    B -.->|HTTP 200 + R√©sultat| F
    B -.->|HTTP 404 Not Found| F
    F -.->|Affiche le r√©sultat ou l'erreur| user
```

> [!NOTE]
> Documentations pour la section:
>  [Documentation Flask](https://flask.palletsprojects.com/en/3.0.x/)
> **-** [Documentation Docker](https://docs.docker.com/)
> **-** [Documentation Redis](https://redis.io/docs/latest/)
> **-** [Documentation RabbitMQ](https://www.rabbitmq.com/docs)
> **-** [RAPPEL Docker](/docs/rappel-docker.md)
> **-** [RAPPEL GitHub & Readme](/docs/rappel-github.md)
> **-** [RAPPEL HTTP/S et API](/docs/rappel-http.md)

---

### [Exigences pour le projet üëà](docs/exigences-projet.md)
